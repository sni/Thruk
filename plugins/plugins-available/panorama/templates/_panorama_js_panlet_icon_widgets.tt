Ext.define('TP.SmallWidget', {
    constructor: function(config) {
        var me = this;
        Ext.apply(me, config);

        this.shadow   = false;
        this.floating = true;
        this.stateful = true;
        this.stateId  = this.id;
        if(this.xdata == undefined) {
            this.xdata = {};
        } else {
            this.xdata = TP.clone(this.xdata);
        }
        var tab     = Ext.getCmp(this.panel_id);
        this.locked = tab.xdata.locked;
        [% IF readonly %]
        this.locked = true;
        [% END %]
        this.redrawOnly = false;
        this.animations = 0;

        this.xdata.cls        = this.$className;
        this.xdata.state      = 4;
        this.xdata.general    = {};
        this.xdata.layout     = { rotation:   0 };
        this.xdata.appearance = { type: 'icon' };
        this.xdata.link     = {};
        this.xdata.label    = { fontfamily:  '',
                                fontsize:     14,
                                fontcolor:   '#000000',
                                position:    'below',
                                orientation: 'horizontal',
                                offsetx:      0,
                                offsety:      0,
                                bgcolor:     '',
                                fontitalic:  '',
                                fontbold:    ''
                            };
        if(this.xdata.general[this.iconType] == undefined) { this.xdata.general[this.iconType] = '' };
        this.autoEl = {
            tag:     'a',
            href:    '#',
            target:  '',
            onclick: "return(TP.iconClickHandler('"+this.id+"'));"
        };

        if(!this.locked) {
            this.stateEvents = ['reconfigure', 'afterlayout', 'move'];
            this.draggable   = true;
        }

        this.getState = function() {
            var state      = {
                xdata: this.xdata
            };
            return state;
        };
        this.origApplyState = this.applyState;
        this.applyState = function(state) {
            Ext.apply(this.xdata, state.xdata);
            this.origApplyState(state);
            if(state) {
                this.applyXdata(state.xdata);
            }
        };
    },
    listeners: {
        afterrender: function(This, eOpts) {
            [% UNLESS readonly %]
            This.addClickEventhandler(This.el);

            if(!this.locked) {
                var pos = this.getPosition();
                this.xdata.layout.x = pos[0];
                this.xdata.layout.y = pos[1];
                if(this.xdata.general[this.iconType] == '' && this.firstRun != false) {
                    this.firstRun = true;
                    TP.suppressIconTip = true;
                    TP.timeouts['timeout_' + this.id + '_show_settings'] = window.setTimeout(function() {
                        // show dialog delayed, so the panel has a position already
                        TP.iconShowEditDialog(This);
                    }, 10);
                }
            }
            [% END %]
            This.applyRotation(This.xdata.layout.rotation);
        },
        show: function( This, eOpts ) {
            This.addDDListener(This);
            /* update label */
            this.setIconLabel();
            if(this.labelEl) { this.labelEl.show(); }
        },
        hide: function(This, eOpts) {
            if(this.labelEl) { this.labelEl.hide(); }
        },
        destroy: function( This, eOpts ) {
            if(!this.redrawOnly) {
                /* remove window from panels window ids */
                TP.removeWindowFromPanels(this.id);
                /* clear state information */
                cp.clear(this.id);
                if(this.labelEl) { this.labelEl.destroy(); }
            }
        },
        move: function(This, x, y, eOpts) {
            var pos = This.getPosition();
            if(x != undefined) { x = Math.floor(x); } else { x = pos[0]; }
            if(y != undefined) { y = Math.floor(y); } else { y = pos[1]; }
            // update settings window
            if(TP.iconSettingsWindow) {
                TP.iconSettingsWindow.items.getAt(0).items.getAt(1).down('form').getForm().setValues({x:x, y:y});
            }
            /* update label */
            this.setIconLabel();
            if(This.stateful) {
                this.xdata.layout.x = Math.floor(x);
                this.xdata.layout.y = Math.floor(y);
            }
        },
        resize: function(This, width, height, oldWidth, oldHeight, eOpts) {
            /* update label */
            this.setIconLabel();
        }
    },
    applyXdata: function(xdata) {
        if(xdata == undefined) { xdata = this.xdata; }

        /* restore missing sections */
        Ext.Array.each(['general', 'layout', 'appearance', 'link', 'label'], function(name, idx) {
            if(xdata[name] == undefined) { xdata[name] = {} };
        });
        if(xdata.appearance['type'] == undefined || xdata.appearance['type'] == '') { xdata.appearance['type'] = 'icon' };

        /* restore position */
        this.setPosition(Number(xdata.layout.x), Number(xdata.layout.y));
        if(xdata.layout.rotation) {
            this.applyRotation(Number(xdata.layout.rotation));
        } else {
            this.applyRotation(0);
        }

        /* set label */
        this.setIconLabel(xdata.label);

        /* recalculate state */
        if(TP.initialized) {
            this.refreshHandler();
        }

        /* add link */
        if(xdata.link && xdata.link.link) {
            this.addCls('clickable');
            this.removeCls('notclickable');
            if(this.el) { this.el.dom.href=xdata.link.link; }
            this.autoEl.href=xdata.link.link;
            if(this.labelEl && this.labelEl.el) {
                this.labelEl.el.dom.href=xdata.link.link;
                this.labelEl.removeCls('notclickable');
                this.labelEl.addCls('clickable');
            }
        } else {
            if(this.el) {
                this.removeCls('clickable');
                this.addCls('notclickable');
            }
            if(this.el) { this.el.dom.href='#'; }
            this.autoEl.href='#';
            if(this.labelEl && this.labelEl.el) {
                this.labelEl.el.dom.href='#';
                this.labelEl.removeCls('clickable');
                this.labelEl.addCls('notclickable');
            }
        }
    },
    /* change size and position animated */
    applyAnimated: function(animated) {
        var win = this;
        win.animations++;
        win.stateful = false;
        var delay = (animated.duration ? animated.duration : 250) + 250;
        window.setTimeout(Ext.bind(function() {
            win.animations--;
            if(win.animations == 0) { win.stateful = true; }
        }, win, []), delay);

        layout = this.xdata.layout;
        animated.to = {x:layout.x, y:layout.y};
        this.animate(animated);
    },
    /* rotates this thing */
    applyRotation: function(value) {
        if(value == undefined) { return; }
        value = value*-1;
        var el = this.el;
        if(this.rotateEl) { el = this.rotateEl; }
        if(!el || !el.dom) { return; }
        el.setStyle("-webkit-transform", "rotate("+value+"deg)");
        el.setStyle("-moz-transform", "rotate("+value+"deg)");
        el.setStyle("-o-transform", "rotate("+value+"deg)");
        el.setStyle("-ms-transform", "rotate("+value+"deg)");
    },
    /* enable / disable editing of this panlet */
    setLock: function(val) {
        var tab = Ext.getCmp(this.panel_id);
        if(this.locked != val) {
            this.saveState();
            this.redrawOnly = true;
            this.destroy();
            TP.add_panlet({id:this.id, skip_state:true, tb:tab, autoshow:true}, false);
        }
    },

    /* render label for this widget */
    setIconLabel: function(cfg, force_perfdata) {
        if(cfg == undefined)          { cfg = this.xdata.label; }
        if(cfg == undefined)          { return; }
        if(!this.el || !this.el.dom)  { return; }
        if(!this.el.dom.style.zIndex) { return; }
        var txt = cfg.labeltext;
        if(txt == undefined) { txt = ''; }
        /* dynamic label? */
        if(force_perfdata || txt.match(/\{\{.*?\}\}/)) {
            var allowed_functions = ['strftime', 'sprintf', 'if'];
            var matches           = txt.match(/(\{\{.*?\}\})/g);
            if(this.servicegroup) { totals = this.servicegroup; }
            if(this.hostgroup)    { totals = this.hostgroup; }
            if(this.results)      { totals = this.results; }
            if(this.host)         { for(var key in this.host)    { window[key] = this.host[key];    } }
            if(this.service)      { for(var key in this.service) { window[key] = this.service[key]; } }
            if(window.perf_data) {
                window.perf_data = parse_perf_data(window.perf_data);
                window.perfdata = {};
                for(var x = 0; x < window.perf_data.length; x++) {
                    var d = window.perf_data[x];
                    window.perfdata[d.key] = d;
                }
            } else {
                window.perfdata = {};
            }
            Ext.Array.each(matches, function(item, idx) {
                var calc      = item.replace(/^\{\{/, '').replace(/\}\}$/, '');
                var functions = calc.match(/[\w+_]+\(/g);
                var ok        = true;
                // only run a few allow functions
                Ext.Array.each(functions, function(f, idx) {
                    f = f.replace(/\($/, '');
                    if(!Ext.Array.contains(allowed_functions, f)) {
                        ok = false;
                    }
                });
                if(!ok) { return; }
                var res = '';
                try {
                    res = eval(calc);
                } catch(e) { debug(e); }
                if(res == undefined) { res = ''; }
                txt = txt.replace(item, res);
            });
        }
        if(!cfg.labeltext) {
            if(this.labelEl) { this.labelEl.destroy(); this.labelEl = undefined; }
            return;
        }
        if(!this.labelEl) {
            var panel = this;
            this.labelEl = Ext.create('Ext.Component', {
                'html':     ' ',
                draggable:  true,
                autoRender: true,
                autoShow:   true,
                shadow:     false,
                cls:        (panel.xdata.link.link ? '' : 'not') +'clickable iconlabel', // defaults to text cursor otherwise
                autoEl: {
                    tag:     'a',
                    href:    panel.xdata.link.link,
                    target:  '',
                    onclick: "return(TP.iconClickHandler('"+panel.id+"'));"
                },
                listeners: {
                    /* move parent element according to our drag / drop */
                    move: function(This, x, y, eOpts) {
                        var diffX = 0, diffY = 0;
                        if(x != undefined && This.oldX != undefined) { diffX = x - This.oldX; }
                        if(y != undefined && This.oldY != undefined) { diffY = y - This.oldY; }
                        if(x != undefined) { This.oldX = x; }
                        if(y != undefined) { This.oldY = y; }
                        if(diffX != 0 || diffY != 0) {
                            var pos = panel.getPosition();
                            panel.setPosition(pos[0]+diffX, pos[1]+diffY);
                            // update settings window
                            if(TP.iconSettingsWindow) {
                                TP.iconSettingsWindow.items.getAt(0).items.getAt(1).down('form').getForm().setValues({x:pos[0]+diffX, y:pos[1]+diffY});
                            }
                        }
                    },
                    afterrender: function(This, eOpts) {
                        panel.addClickEventhandler(This.el);
                    },
                    show: function( This, eOpts ) {
                        panel.addDDListener(This);
                    }
                }
            });
            if(panel.rotateLabel) {
                panel.rotateEl = panel.labelEl.el;
            }
            panel.applyRotation(panel.xdata.layout.rotation);
        }
        var el = this.labelEl.el.dom;
        el.style.zIndex       = Number(this.el.dom.style.zIndex)+1; /* keep above icon */
        this.labelEl.update(txt);
        el.style.color        = cfg.fontcolor;
        el.style.fontFamily   = cfg.fontfamily;
        el.style.background   = cfg.bgcolor;
        el.style.fontWeight   = cfg.fontbold   ? 'bold'   : 'normal';
        el.style.fontStyle    = cfg.fontitalic ? 'italic' : 'normal';
        el.style.paddingLeft  = "3px";
        el.style.paddingRight = "3px";
        if(cfg.orientation == 'vertical') { this.labelEl.addCls('vertical');    }
        else                              { this.labelEl.removeCls('vertical'); }

        var left          = TP.extract_number_with_unit({ value: this.el.dom.style.left, unit:'px',  floor: true, defaultValue: 100 });
        var top           = TP.extract_number_with_unit({ value: this.el.dom.style.top,  unit:'px',  floor: true, defaultValue: 100 });
        var offsetx       = TP.extract_number_with_unit({ value: cfg.offsetx,            unit:' px', floor: true, defaultValue:   0 });
        var offsety       = TP.extract_number_with_unit({ value: cfg.offsety,            unit:' px', floor: true, defaultValue:   0 });
        var fontsize      = TP.extract_number_with_unit({ value: cfg.fontsize,           unit:' px', floor: true, defaultValue:  14 });
        var elWidth       = TP.extract_number_with_unit({ value: this.width,             unit:'',    floor: true, defaultValue:   0 });
        var elHeight      = TP.extract_number_with_unit({ value: this.height,            unit:'',    floor: true, defaultValue:   0 });
        var bordersize    = TP.extract_number_with_unit({ value: cfg.bordersize,         unit:' px', floor: true, defaultValue:   0 });

        if(cfg.bordercolor && bordersize > 0) {
            el.style.border = bordersize+"px solid "+cfg.bordercolor;
        } else {
            el.style.border = "";
        }

        el.style.fontSize = fontsize+'px';
        var size          = this.labelEl.getSize();
        if(size.width == 0) { return; }

        if(cfg.position == 'above') {
            top = top - offsetx - size.height;
            if(cfg.orientation == 'horizontal') {
                left = left + (elWidth / 2) - (size.width / 2) + 2;
            }
            left = left - offsety;
        }
        if(cfg.position == 'below') {
            top = top + offsetx + elHeight;
            if(cfg.orientation == 'horizontal') {
                left = left + (elWidth / 2) - (size.width / 2) + 2;
            }
            left = left - offsety;
        }
        if(cfg.position == 'right') {
            left = left + offsetx + elWidth + 2;
            if(cfg.orientation == 'horizontal') {
                top  = top + elHeight/2 - size.height/2;
            }
            top = top - offsety;
        }
        if(cfg.position == 'left') {
            left = left - offsetx - size.width - 2;
            if(cfg.orientation == 'horizontal') {
                top  = top + elHeight/2 - size.height/2;
            }
            top = top - offsety;
        }
        el.style.left = left+"px";
        el.style.top  = top+"px";
        this.labelEl.oldX = left;
        this.labelEl.oldY = top;
    },

    /* add dbl click and context menu events */
    addClickEventhandler: function(el) {
        var This = this;
        /* open edit box on double or right click */
        el.on("dblclick", function(e) {
            window.clearTimeout(TP.timeouts['click'+This.id]);
            if(!This.locked) {
                TP.iconShowEditDialog(This);
            }
        });

        /* right click context menu on icon widgets */
        el.on("contextmenu", function(e) {
            e.preventDefault();
            Ext.create('Ext.menu.Menu', {
                margin: '0 0 10 0',
                items: [{
                    text:   'Refresh',
                    icon:   '[% url_prefix %]plugins/panorama/images/arrow_refresh.png',
                    handler: function() { TP.updateAllIcons(Ext.getCmp(This.panel_id), This.id) },
                    hidden:  This.xdata.state == undefined ? true : false
                }, {
                    text:       'Show Details',
                    icon:       '[% url_prefix %]plugins/panorama/images/application_view_columns.png',
                    href:       'status.cgi',
                    hrefTarget: '_blank',
                    listeners: {
                        afterrender: function(btn, eOpts) { btn.el.dom.children[0].href = TP.getIconDetailsLink(This); }
                    },
                    hidden:  This.xdata.state == undefined ? true : false
                }, {
                    text:   'Settings',
                    icon:   '[% url_prefix %]plugins/panorama/images/cog.png',
                    handler: function() { TP.iconShowEditDialog(This) },
                    disabled: This.locked
                }, '-', {
                    text:   'Copy',
                    icon:   '[% url_prefix %]plugins/panorama/images/page_copy.png',
                    handler: function() { TP.clipboard = {type:This.xdata.cls, state:TP.clone_panel_config(This)} }
                }, {
                    text:   'Paste',
                    icon:   '[% url_prefix %]plugins/panorama/images/page_paste.png',
                    handler: function() { TP.add_panlet_delayed(TP.clipboard, -8, -8) },
                    disabled: (This.locked || TP.clipboard == undefined)
                }, {
                    text:   'Clone',
                    icon:   '[% url_prefix %]plugins/panorama/images/page_lightning.png',
                    handler: function() { TP.add_panlet_delayed({type:This.xdata.cls, state:TP.clone_panel_config(This)}, -8, -8) },
                    disabled: This.locked
                }, '-', {
                    text:   'Remove',
                    icon:   '[% url_prefix %]plugins/panorama/images/delete.png',
                    disabled: This.locked,
                    handler: function(me, eOpts) {
                        var menu = me.parentMenu;
                        var i = menu.items.findIndexBy(function(e) { if(e.text == 'Remove') {return true;} });
                        menu.remove(i);
                        menu.add({
                            xtype: 'panel',
                            border: false,
                            bodyStyle: 'background: #F0F0F0;',
                            items: [{
                                xtype:  'label',
                                text:   'Remove? ',
                                style:  'top: 3px; position: relative; color: red; font-weight: bold;'
                            },{
                                xtype:  'button',
                                text:   'No',
                                width:  30,
                                handler: function() { menu.destroy(); }
                            }, {
                                xtype: 'button',
                                text:  'Yes',
                                width:  30,
                                handler: function() { This.destroy(); menu.destroy(); }
                            }]
                        });
                        menu.move(menu.items.length, i);
                    }
                }],
                listeners: {
                    beforehide: function(menu, eOpts) { menu.destroy(); }
                }
            }).showBy(This);
        });
    },
    addDDListener: function(el) {
        var panel = this;
        if(el.dd && !el.dd_listener_added) {
            el.dd.addListener('dragstart', function(This, eOpts) {
                window.clearTimeout(TP.timeouts['click'+panel.id]);
                TP.suppressIconTip = true;
            });
            el.dd.addListener('dragend', function(This, eOpts) {
                /* prevents opening link after draging */
                window.setTimeout(function() {
                    window.clearTimeout(TP.timeouts['click'+panel.id]);
                }, 100);
                TP.suppressIconTip = false;
                panel.setIconLabel();
            });
            el.dd_listener_added = true;
        }
    }
});

Ext.define('TP.IconWidget', {
    extend: 'Ext.container.Container',
    mixins: {
        smallWidget: 'TP.SmallWidget'
    },

    cls:      'iconWidget',
    floating:  true,
    width:     22,
    height:    22,

    constructor: function (config) {
        this.mixins.smallWidget.constructor.call(this, config);
        this.callParent();
    },
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.addListener('afterrender', function(This, eOpts) {
            this.setRenderItem();
        });
    },
    items: [],
    applyXdata: function(xdata) {
        if(xdata == undefined) { xdata = this.xdata; }
        this.mixins.smallWidget.applyXdata.call(this, xdata);
        if(xdata.nsize && xdata.size) {
            var size = Math.ceil(Math.sqrt(Math.pow(xdata.nsize[0], 2) + Math.pow(xdata.nsize[1], 2)));
            this.setSize(size, size);
        }
        if(this.lastType != xdata.appearance.type) {
            this.setRenderItem(xdata);
        } else {
            this.updateRender(xdata);
        }
        this.lastType = xdata.appearance.type;
    },
    refreshHandler: function(newStatus) {
        var tab   = Ext.getCmp(this.panel_id);
        var panel = this;
        if(TP.iconSettingsWindow && TP.iconSettingsWindow.panel == panel) { return; }
        var oldState = panel.xdata.state;
        if(newStatus != undefined) {
            panel.xdata.state = newStatus;
        }
        this.updateRender();
        if(newStatus != undefined && oldState != newStatus) {
            panel.xdata.state = newStatus;
            if(panel.el && (oldState != 4 && oldState != undefined)) { // not when initial state was pending
                TP.timeouts['timeout_' + panel.id + '_flicker'] = window.setTimeout(Ext.bind(TP.flickerImg, panel, [panel.el.id]), 200);
            }
        }
        panel.setIconLabel();
    },

    /* update shapes and stuff */
    updateRender: function(xdata) {
        var panel = this;
        if(xdata == undefined) { xdata = panel.xdata; }
        if(xdata.appearance.type == 'shape')       { panel.shapeRender(xdata);            }
        if(xdata.appearance.type == 'pie')         { panel.pieRender(xdata);              }
        if(xdata.appearance.type == 'speedometer') { panel.speedoRender(xdata);           }
        if(xdata.appearance.type == 'icon')        { panel.iconSetSourceFromState(xdata); }
    },

    /* rotates this thing */
    applyRotation: function(value) {
        if(value        == undefined) { return; }
        if(this.surface == undefined) { return; }
        if(this.surface.items.getAt(0) == undefined) { return; }
        this.surface.items.getAt(0).setAttributes({rotate:{degrees: -1*value}}, true);
    },

    /* return totals array which can be used in a store */
    getTotals: function(xdata, colors) {
        var panel = this;
        if(xdata == undefined) { xdata = panel.xdata; }
        var totals = [];
        var hosts  = {}, services = {};
        if(panel.hostgroup) {
            if(xdata.general.incl_hst) { hosts    = panel.hostgroup.hosts;    }
            if(xdata.general.incl_svc) { services = panel.hostgroup.services; }
        }
        else if(panel.servicegroup) { services = panel.servicegroup.services; }
        else if(panel.results) {
            if(xdata.general.incl_hst) { hosts    = panel.results.hosts;    }
            if(xdata.general.incl_svc) { services = panel.results.services; }
        }
        else {
            var state = xdata.state;
            if(panel.iconType == 'host') {
                if(state == 0) { totals.push({name: 'up',          value: 1, color: colors['up'] }); }
                if(state == 1) { totals.push({name: 'down',        value: 1, color: colors['down'] }); }
                if(state == 2) { totals.push({name: 'unreachable', value: 1, color: colors['unreachable'] }); }
            } else {
                if(state == 0) { totals.push({name: 'ok',       value: 1, color: colors['ok'] }); }
                if(state == 1) { totals.push({name: 'warning',  value: 1, color: colors['warning'] }); }
                if(state == 2) { totals.push({name: 'critical', value: 1, color: colors['critical'] }); }
                if(state == 3) { totals.push({name: 'unknown',  value: 1, color: colors['unknown'] }); }
            }
            if(state == 4) { totals.push({name: 'pending', value: 1, color: colors['pending'] }); }
        }
        Ext.Array.each(['down', 'unreachable', 'critical', 'unknown', 'warning', 'up', 'ok', 'pending'], function(name, i) {
            if(   hosts[name]) { totals.push({name: name, value:    hosts[name], color: colors[name] }); }
            if(services[name]) { totals.push({name: name, value: services[name], color: colors[name] }); }
        });
        if(totals.length == 0) { totals.push({name: 'none', value: 1, color: colors['pending'] }); }
        return(totals);
    },

    /* set main render item*/
    setRenderItem: function(xdata, forceRecreate) {
        var panel = this;
        if(xdata == undefined) { xdata = panel.xdata; }
        if(panel.itemRendering && !forceRecreate) { return; }
        panel.itemRendering = true;
        panel.removeAll();
        panel.surface  = undefined;
        panel.icon     = undefined;
        panel.chart    = undefined;

        var x       = 0;
        var y       = 0;
        var width   = 16;
        var height  = 16;
        var size;
        if(xdata.nsize && xdata.size) {
            x        = (xdata.size - xdata.nsize[0]) / 2;
            y        = (xdata.size - xdata.nsize[1]) / 2;
            width    = xdata.nsize[0];
            height   = xdata.nsize[1];
            size     = xdata.size;
            var size = Math.ceil(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)));
            panel.setSize(size,size);
        } else if(panel.xdata.size && panel.xdata.nsize && panel.xdata.nsize[0] > 1) {
            x        = (panel.xdata.size - panel.xdata.nsize[0]) / 2;
            y        = (panel.xdata.size - panel.xdata.nsize[1]) / 2;
            width    = panel.xdata.nsize[0];
            height   = panel.xdata.nsize[1];
            size     = panel.xdata.size;
            var size = Math.ceil(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)));
            panel.setSize(size,size);
        } else {
            size = Math.ceil(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)));
            x    = (size - width)  / 2;
            y    = (size - height) / 2;
        }

        if(xdata.appearance.type == 'icon' || xdata.appearance.type == 'shape') {
            var items = [];
            if(xdata.appearance.type == 'icon') {
                if(xdata.layout.rotation == undefined) { xdata.layout.rotation = 0; }
                items = [{
                    type:      'image',
                    src:        Ext.BLANK_IMAGE_URL,
                    width:      width,
                    height:     height,
                    x:          x,
                    y:          y,
                    rotation: { degrees: -1*xdata.layout.rotation }
                }];
            }
            panel.add({
                viewBox:   false,
                xtype:    'draw',
                width:     size,
                height:    size,
                items:     items,
                style:     'vertical-align:inherit;',
                listeners: {
                    afterrender: function(This, eOpts) {
                        panel.itemRendering = false;
                        panel.surface = panel.items.getAt(0).surface;
                        if(xdata.appearance.type == 'icon') {
                            panel.icon = panel.items.getAt(0).surface.items.getAt(0);
                            This.el.down('image').on("load", function (evt, ele, opts) {
                                panel.iconFixSize();
                            });
                        }
                        panel.updateRender(xdata);
                    }
                }
            });
        }
        else if(xdata.appearance.type == 'pie') {
            var pieStore = Ext.create('Ext.data.Store', {
                fields: ['name','value'],
                data:  []
            });
            panel.add({
                xtype:  'tp_piechart',
                store:   pieStore,
                panel:   panel,
                animate: false,
                shadow:  xdata.appearance.pieshadow,
                donut:   xdata.appearance.piedonut,
                listeners: {
                    afterrender: function(This, eOpts) {
                        panel.itemRendering = false;
                        panel.chart = This;
                        panel.updateRender(xdata);
                    }
                }
            });
        }
        else if(xdata.appearance.type == 'speedometer') {
            panel.add({
                xtype:       'tp_speedochart',
                store:        [0],
                panel:        panel,
                insetPadding: xdata.appearance.speedomargin > 0 ? xdata.appearance.speedomargin + 20 : 10,
                shadow:       xdata.appearance.speedoshadow,
                donut:        xdata.appearance.speedodonut,
                needle:       xdata.appearance.speedoneedle,
                axis_margin:  xdata.appearance.speedomargin == 0 ? 0.1 : xdata.appearance.speedomargin,
                axis_steps:   xdata.appearance.speedosteps,
                axis_min:     xdata.appearance.speedoaxis_min ? xdata.appearance.speedoaxis_min : 0,
                axis_max:     xdata.appearance.speedoaxis_max ? xdata.appearance.speedoaxis_max : 0,
                listeners: {
                    afterrender: function(This, eOpts) {
                        panel.itemRendering = false;
                        panel.chart = This;
                        panel.updateRender(xdata);
                    },
                    resize: function(This, eOpts) {
                        panel.updateRender(xdata);
                    }
                }
            });
        }
        else {
            panel.itemRendering = false;
        }
    },

    /* renders speedometer chart */
    speedoRender: function(xdata, forceColor) {
        var panel = this;
        if(xdata == undefined) { xdata = panel.xdata; }
        if(xdata.appearance.type != 'speedometer') { return }
        if(!panel.chart) {
            panel.setRenderItem(xdata);
            return;
        }
        var extraSpace = 0;
        panel.items.getAt(0).setSize(xdata.appearance.speedowidth, xdata.appearance.speedowidth/1.8);
        panel.setSize(xdata.appearance.speedowidth, xdata.appearance.speedowidth/1.8);
        var colors = {
            pending:  xdata.appearance.speedocolor_pending  ? xdata.appearance.speedocolor_pending  : '#ACACAC',
            ok:       xdata.appearance.speedocolor_ok       ? xdata.appearance.speedocolor_ok       : '#00FF33',
            warning:  xdata.appearance.speedocolor_warning  ? xdata.appearance.speedocolor_warning  : '#FFDE00',
            unknown:  xdata.appearance.speedocolor_unknown  ? xdata.appearance.speedocolor_unknown  : '#FF9E00',
            critical: xdata.appearance.speedocolor_critical ? xdata.appearance.speedocolor_critical : '#FF5B33',
            bg:       xdata.appearance.speedocolor_bg       ? xdata.appearance.speedocolor_bg       : '#DDDDDD'
        };

        // which source to use
        var state  = xdata.state, value = 0, min = 0, max = 100;
        if(state == undefined) { state = panel.xdata.state; }
        if(xdata.appearance.speedosource == undefined) { xdata.appearance.speedosource = 'problems'; }
        var matches = xdata.appearance.speedosource.match(/^perfdata:(.*)$/);
        if(matches && matches[1]) {
            window.perfdata = {};
            panel.setIconLabel(undefined, true);
            if(perfdata[matches[1]]) {
                var p = perfdata[matches[1]];
                value = p.val;
                var r = TP.getPerfDataMinMax(p, 100);
                max   = r.max;
                min   = r.min;
            }
        }
        else if(xdata.appearance.speedosource == 'problems' || xdata.appearance.speedosource == 'problems_warn') {
            var totals = this.getTotals(xdata, colors);
            max = 0;
            Ext.Array.each(totals, function(t,i) {
                max += t.value;
                if(t.name == 'critical' || t.name == 'unknown' || t.name == 'down' || t.name == 'unreachable') {
                    value += t.value;
                }
                if(xdata.appearance.speedosource == 'problems_warn' && t.name == 'warning') {
                    value += t.value;
                }
            });
        }
        if(panel.chart.axes.getAt(0).minimum != min || panel.chart.axes.getAt(0).maximum != max) {
            xdata.appearance.speedoaxis_min = min;
            xdata.appearance.speedoaxis_max = max;
            panel.setRenderItem(xdata);
            return;
        }
        if(value > max) { value = max; } // value cannot exceed speedo
        var color_fg = colors['unknown'];
        if(state == 0) { color_fg = colors['ok'];       }
        if(state == 1) { color_fg = colors['warning'];  }
        if(state == 2) { color_fg = colors['critical']; }
        if(state == 3) { color_fg = colors['unknown'];  }
        if(state == 4) { color_fg = colors['pending'];  }

        var colorSet = [];
        Ext.Array.each([color_fg, colors['bg']], function(color,i) {
            if(forceColor) { color = forceColor; }
            if(xdata.appearance.speedogradient != 0) {
                var gradient = TP.createGradient(color, xdata.appearance.speedogradient);
                if(panel.chart.surface.existingGradients == undefined) { panel.chart.surface.existingGradients = {} }
                if(panel.chart.surface.existingGradients[gradient.id] == undefined) {
                    panel.chart.surface.existingGradients[gradient.id] = true;
                    panel.chart.surface.addGradient(gradient);
                }
                colorSet.push('url(#'+gradient.id+')');
            } else {
                colorSet.push(color);
            }
        });
        panel.chart.series.getAt(0).colorSet = colorSet;
        if(panel.chart.series.getAt(0).setValue) {
            if(value == 0) { value = 0.0001; } // doesn't draw anything otherwise
            panel.chart.series.getAt(0).setValue(value);
        }
    },

    /* renders pie chart */
    pieRender: function(xdata, forceColor) {
        var panel = this;
        if(xdata == undefined) { xdata = panel.xdata; }
        if(xdata.appearance.type != 'pie') { return }
        if(!panel.chart) {
            panel.setRenderItem(xdata);
            return;
        }
        if(xdata.appearance.pielocked) { xdata.appearance.pieheight = xdata.appearance.piewidth; }
        panel.items.getAt(0).setSize(xdata.appearance.piewidth, xdata.appearance.pieheight);
        panel.setSize(xdata.appearance.piewidth, xdata.appearance.pieheight);
        var colors = {
            up:          xdata.appearance.piecolor_up          ? xdata.appearance.piecolor_up          : '#00FF33',
            down:        xdata.appearance.piecolor_down        ? xdata.appearance.piecolor_down        : '#FF5B33',
            unreachable: xdata.appearance.piecolor_unreachable ? xdata.appearance.piecolor_unreachable : '#FF7A59',
            pending:     xdata.appearance.piecolor_pending     ? xdata.appearance.piecolor_pending     : '#ACACAC',
            ok:          xdata.appearance.piecolor_ok          ? xdata.appearance.piecolor_ok          : '#00FF33',
            warning:     xdata.appearance.piecolor_warning     ? xdata.appearance.piecolor_warning     : '#FFDE00',
            unknown:     xdata.appearance.piecolor_unknown     ? xdata.appearance.piecolor_unknown     : '#FF9E00',
            critical:    xdata.appearance.piecolor_critical    ? xdata.appearance.piecolor_critical    : '#FF5B33'
        };
        var totals   = this.getTotals(xdata, colors);
        var colorSet = [];
        Ext.Array.each(totals, function(t,i) {
            var color = t.color;
            if(forceColor) { color = forceColor; }
            if(xdata.appearance.piegradient != 0) {
                var gradient = TP.createGradient(color, xdata.appearance.piegradient);
                if(panel.chart.surface.existingGradients == undefined) { panel.chart.surface.existingGradients = {} }
                if(panel.chart.surface.existingGradients[gradient.id] == undefined) {
                    panel.chart.surface.existingGradients[gradient.id] = true;
                    panel.chart.surface.addGradient(gradient);
                }
                colorSet.push('url(#'+gradient.id+')');
            } else {
                colorSet.push(color);
            }
        });
        panel.chart.series.getAt(0).colorSet = colorSet;
        var pieStore = Ext.create('Ext.data.Store', {
            fields: ['name','value'],
            data:  []
        });
        TP.updateArrayStoreHash(pieStore, totals);
        panel.chart.bindStore(pieStore);
        panel.chart.panel.xdata.showlabel = !!xdata.appearance.pielabel;
        panel.chart.setShowLabel();
    },

    /* renders shape */
    shapeRender: function(xdata, forceColor, panel) {
        if(panel == undefined) { panel = this; }
        if(xdata == undefined) { xdata = panel.xdata; }
        if(xdata.appearance.type != 'shape') { return }

        if(xdata.appearance.shapename == undefined) { return; }
        if(!panel.surface) {
            panel.setRenderItem(xdata);
            return;
        }
        var shapeData;
        TP.shapesStore.findBy(function(rec, id) {
            if(rec.data.name == xdata.appearance.shapename) {
                shapeData = rec.data.data;
            }
        });
        if(shapeData == undefined) {
            if(initial_shapes[xdata.appearance.shapename]) {
                shapeData = initial_shapes[xdata.appearance.shapename];
            } else {
                TP.Msg.msg("fail_message~~loading shape '"+xdata.appearance.shapename+"' failed: no such shape");
                return;
            }
        }

        shapeData = shapeData.replace(/,\s*$/, ''); // remove trailing commas
        var state = xdata.state, fillcolor;
        if(state == undefined) { state = panel.xdata.state; }
        if(forceColor != undefined) { fillcolor = forceColor; }
        else if(state == 0)         { fillcolor = xdata.appearance.shapecolor_ok; }
        else if(state == 1)         { fillcolor = xdata.appearance.shapecolor_warning; }
        else if(state == 2)         { fillcolor = xdata.appearance.shapecolor_critical; }
        else if(state == 3)         { fillcolor = xdata.appearance.shapecolor_unknown; }
        else if(state == 4)         { fillcolor = "#777777"; }
        if(!fillcolor) { fillcolor = '#333333'; }
        if(xdata.appearance.shapegradient != 0) {
            if(panel.surface.existingGradients == undefined) { panel.surface.existingGradients = {}; }

            if(xdata.appearance.shapesource == undefined) { xdata.appearance.shapesource = 'fixed'; }
            var matches = xdata.appearance.shapesource.match(/^perfdata:(.*)$/);
            if(xdata.appearance.shapesource != 'fixed' && matches && matches[1]) {
                /* dynamic gradient */
                window.perfdata = {};
                panel.setIconLabel(undefined, true);
                if(perfdata[matches[1]]) {
                    var p = perfdata[matches[1]];
                    var r = TP.getPerfDataMinMax(p, 100);
                    var color1 = xdata.appearance.shapecolor_ok;
                    var color2 = xdata.appearance.shapecolor_ok;
                    var perc  = 100;
                    /* inside critical range: V c w o w c  */
                    if(p.crit_min != "" && p.val < p.crit_min) {
                        color1 = xdata.appearance.shapecolor_critical;
                        color2 = xdata.appearance.shapecolor_critical;
                        perc   = 100;
                    }
                    /* above critical threshold: o w c V */
                    else if(p.crit_max != "" && p.val > p.crit_max) {
                        color1 = xdata.appearance.shapecolor_critical;
                        color2 = xdata.appearance.shapecolor_critical;
                        perc   = 100;
                    }
                    /* inside warning range low: c V w o w c */
                    else if(p.warn_min != "" && p.val < p.warn_min && p.val > p.crit_min) {
                        color1 = xdata.appearance.shapecolor_warning;
                        color2 = xdata.appearance.shapecolor_critical;
                        perc = Math.floor(((p.warn_min - p.val) / (p.warn_min - p.crit_min))*100);
                    }
                    /* inside warning range high: c w o w V c */
                    else if(p.warn_min != "" && p.val > p.warn_max && p.val < p.crit_max) {
                        color1 = xdata.appearance.shapecolor_warning;
                        color2 = xdata.appearance.shapecolor_critical;
                        perc = Math.floor(((p.val - p.warn_max) / (p.crit_max - p.warn_max))*100);
                    }
                    /* above warning threshold: o w V c */
                    else if(p.warn_max != "" && p.val > p.warn_max) {
                        color1 = xdata.appearance.shapecolor_warning;
                        color2 = xdata.appearance.shapecolor_critical;
                        perc   = Math.floor(((p.val - p.warn_max) / (r.max - p.warn_max))*100);
                    }
                    /* below warning threshold: o V w c */
                    else if(p.warn_max != "" && p.val < p.warn_max) {
                        color1 = xdata.appearance.shapecolor_ok;
                        color2 = xdata.appearance.shapecolor_warning;
                        perc   = Math.floor(((p.val - r.min) / (p.warn_max - r.min))*100);
                    }
                    var gradient = TP.createGradient(color1, xdata.appearance.shapegradient, color2, perc);
                    if(panel.surface.existingGradients[gradient.id] == undefined) {
                        panel.surface.addGradient(gradient);
                        panel.surface.existingGradients[gradient.id] = true;
                    }
                    shapeData += ",fill:'url(#"+gradient.id+")'";
                }
            } else {
                /* fixed gradient */
                var gradient = TP.createGradient(fillcolor, xdata.appearance.shapegradient);
                if(panel.surface.existingGradients[gradient.id] == undefined) {
                    panel.surface.addGradient(gradient);
                    panel.surface.existingGradients[gradient.id] = true;
                }
                shapeData += ",fill:'url(#"+gradient.id+")'";
            }
        } else {
            shapeData += ",fill:'"+fillcolor+"'";
        }
        var spriteData;
        try {
            eval("spriteData = {"+shapeData+"};");
        }
        catch(e) {
            TP.Msg.msg("fail_message~~loading shape '"+xdata.appearance.shapename+"' failed: "+e);
            debug(e);
            return;
        }
        panel.surface.removeAll();
        sprite = panel.surface.add(spriteData);
        var box = sprite.getBBox();
        var xScale = xdata.appearance.shapewidth/box.width;
        var yScale = xdata.appearance.shapeheight/box.height;
        if(xdata.appearance.shapelocked) { yScale = xScale; }
        sprite.setAttributes({scale:{x:xScale,y:yScale}}, true);
        if(xdata.layout.rotation == undefined) { xdata.layout.rotation = 0; }
        sprite.setAttributes({rotate:{degrees: -1*xdata.layout.rotation}}, true);
        box = sprite.getBBox();
        sprite.setAttributes({translate:{x:-box.x,y:-box.y}}, true);
        panel.setSize(Math.ceil(box.width), Math.ceil(box.height));
        if(panel.items.getAt && panel.items.getAt(0)) {
            panel.items.getAt(0).setSize(Math.ceil(box.width), Math.ceil(box.height));
        }
        sprite.show(true);
    },
    iconSetSourceFromState: function(xdata) {
        var panel = this;
        if(xdata       == undefined) { xdata = panel.xdata; }
        if(xdata.state == undefined) { xdata.state = panel.xdata.state; }
        if(xdata.state == undefined) { xdata.state = 4; }
        var tab   = Ext.getCmp(panel.panel_id);
        if(!panel.icon) {
            panel.setRenderItem(xdata);
            return;
        }
        iconset = xdata.appearance.iconset;
        if(iconset == '' || iconset == undefined) {
            iconset = tab.xdata.defaulticonset || 'default';
        }
        var newSrc;
        if(panel.iconType == 'host') {
            if(panel.acknowledged) {
                     if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_down.png';        }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_unreachable.png'; }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_unknown.png';     }
            }
            else if(panel.downtime) {
                if(     xdata.state == 0) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_up.png';          }
                else if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_down.png';        }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_unreachable.png'; }
                else if(xdata.state == 4) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_pending.png';     }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/downtime_unknown.png';     }
            } else {
                if(     xdata.state == 0) { newSrc = '../usercontent/images/status/'+iconset+'/up.png';          }
                else if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/down.png';        }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/unreachable.png'; }
                else if(xdata.state == 4) { newSrc = '../usercontent/images/status/'+iconset+'/pending.png';     }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/unknown.png';     }
            }
        } else {
            if(panel.acknowledged) {
                     if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_warning.png';  }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_critical.png'; }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/acknowledged_unknown.png';  }
            }
            else if(panel.downtime) {
                if(     xdata.state == 0) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_ok.png';       }
                else if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_warning.png';  }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_critical.png'; }
                else if(xdata.state == 4) { newSrc = '../usercontent/images/status/'+iconset+'/downtime_pending.png';  }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/downtime_unknown.png';  }
            } else {
                if(     xdata.state == 0) { newSrc = '../usercontent/images/status/'+iconset+'/ok.png';       }
                else if(xdata.state == 1) { newSrc = '../usercontent/images/status/'+iconset+'/warning.png';  }
                else if(xdata.state == 2) { newSrc = '../usercontent/images/status/'+iconset+'/critical.png'; }
                else if(xdata.state == 4) { newSrc = '../usercontent/images/status/'+iconset+'/pending.png';  }
                else                            { newSrc = '../usercontent/images/status/'+iconset+'/unknown.png';  }
            }
        }
        panel.src = newSrc;
        panel.icon.setAttributes({src: newSrc}).redraw();
    },
    iconFixSize: function() {
        var panel = this;
        if(!panel.icon) { return; }
        if(TP.imageSizes == undefined) { TP.imageSizes = {} }
        var src = panel.icon.el.dom.href.baseVal;
        if(TP.imageSizes[src] == undefined) {
            var img = Ext.create('Ext.Img', {
                src:       Ext.BLANK_IMAGE_URL,
                width:     1,
                height:    1,
                style:    "position: absolute; top: -1px;",
                floating:  true,
                listeners: {
                    afterrender: function(This, eOpts) {
                        This.setSrc(src);
                        This.el.on("load", function (evt, ele, opts) {
                            var naturalWidth  = This.el.dom.naturalWidth;
                            var naturalHeight = This.el.dom.naturalHeight;
                            if(naturalWidth > 1 && naturalHeight > 1) {
                                TP.imageSizes[src] = [naturalWidth, naturalHeight];
                                panel.iconFixSize();
                            }
                            This.destroy();
                        });
                    }
                }
            }).show();
            return;
        }
        var naturalWidth  = TP.imageSizes[src][0];
        var naturalHeight = TP.imageSizes[src][1];
        if(naturalWidth > 1 && naturalHeight > 1) {
            var size = Math.ceil(Math.sqrt(Math.pow(naturalWidth, 2) + Math.pow(naturalHeight, 2)));
            panel.setSize(size, size);
            panel.items.getAt(0).setSize(size, size);
            panel.xdata.size  = size;
            panel.xdata.nsize = [naturalWidth, naturalHeight];
            panel.icon.setAttributes({translation:{x:0, y:0}, scale: {x:1, y:1}}, true);
            this.setIconLabel();
        }
    }
});

TP.suppressIconTip    = false;
Ext.onReady(function() {
    TP.iconTip = Ext.create('Ext.tip.ToolTip', {
        title:    'Details:',
        itemId:   'iconTip',
        target:    Ext.getBody(),
        delegate: 'A.iconWidget', // the cell class in which the tooltip has to be triggered
        showDelay: 500,
        dismissDelay: 0,
        width:     400,
        maxWidth:  400,
        //closable:  true,  // enable for easier css debuging
        style:    'background: #E5E5E5',
        bodyStyle:'background: #E5E5E5',
        shadow:   'drop',
        html:      '',
        listeners: {
            show: function(This) {
                if(TP.suppressIconTip) {
                    This.hide();
                    return false;
                }
            }
        }
    });

    var tipRenderer = function (e, el, eOpts) {
        e.stopEvent();
        var img = Ext.getCmp(el.id);
        if(img.iconType == 'filtered') {
            TP.iconTip.setTitle(img.getName());
        } else {
            TP.iconTip.setTitle(ucfirst(img.iconType)+': '+img.getName());
        }
        var d = img.getDetails();
        var details = '<table class="iconDetails">';
        for(var x=0; x<d.length; x++) {
            details += '<tr>';
            details += '<th>'+d[x][0]+'</th>';
            details += '<td>'+d[x][1]+'</td>';
            details += '</tr>';
        }
        details += '</table>';
        TP.iconTip.update(details);
        TP.iconTip.show();
    };

    Ext.getBody().on('mouseover', function(e,t,a) {
        tipRenderer(e,t,a);
    }, null, {delegate:'A.iconWidget'});
});


/* Host Status Icon */
Ext.define('TP.HostStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'host',
    iconName: 'Hostname',
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.xdata.general.incl_downtimes = false;
        this.xdata.general.incl_ack       = false;
    },
    getGeneralItems: function() {
        var panel = this;
        return([
            TP.objectSearchItem(panel, 'host', 'Hostname'),
            {
                fieldLabel: 'Include Downtimes',
                xtype:      'checkbox',
                name:       'incl_downtimes',
                boxLabel:   '(alert during downtimes too)'
            }, {
                fieldLabel: 'Include Acknowledged',
                xtype:      'checkbox',
                name:       'incl_ack',
                boxLabel:   '(alert for acknowledged problems too)'
            }
        ]);
    },
    getName: function() {
        return(this.xdata.general.host);
    },
    getDetails: function() {
        var details = [];
        if(!this.host) {
            return([['Status', 'No status information available']]);
        }
        var statename = TP.text_host_status(this.xdata.state);
        details.push([ 'Current Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>'
                                        +' (for ' + TP.render_duration('', '', {data:this.host})+')<br>'
                                        +(this.acknowledged ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_ack.png" style="vertical-align:text-bottom"> acknowledged)':'')
                                        +(this.downtime     ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_downtime.png" style="vertical-align:text-bottom"> in downtime)':'')
                     ]);
        details.push([ 'Status Information', this.host.plugin_output]);
        details.push([ 'Last Check', this.host.last_check ? TP.date_format(this.host.last_check) : 'never']);
        details.push([ 'Last Notification', (this.host.last_notification == 0 ? 'N/A' : TP.date_format(this.host.last_notification)) + ' (notification '+this.host.current_notification_number+')']);
        return(details);
    },
    refreshHandler: function(newStatus) {
        this.acknowledged = false;
        this.downtime     = false;
        if(this.host) {
            if(this.host.scheduled_downtime_depth > 0) { this.downtime     = true; }
            if(this.host.acknowledged             > 0) { this.acknowledged = true; }
        }
        this.callParent([newStatus]);
    }
});

/* get summarized table for hosts */
TP.get_summarized_hoststatus = function(item) {
    var table = '<table class="ministatus"><tr>';
    table += '<th>Up</th><th>Unreachable</th><th>Down</th><th>Pending</th></tr><tr>';
    table += '<td class='+(item.up ? 'UP' : 'miniEmpty')+'>'+item.up+'</td>';
    table += '<td class='+(item.unreachable ? 'UNREACHABLE' : 'miniEmpty')+'>'+item.unreachable+'</td>';
    table += '<td class='+(item.down ? 'DOWN' : 'miniEmpty')+'>'+item.down+'</td>';
    table += '<td class='+(item.pending ? 'PENDING' : 'miniEmpty')+'>'+item.pending+'</td>';
    table += '</tr></table>';
    return(table);
}

/* get summarized table for services */
TP.get_summarized_servicestatus = function(item) {
    var table = '<table class="ministatus"><tr>';
    table += '<th>Ok</th><th>Warning</th><th>Critical</th><th>Unknown</th><th>Pending</th></tr><tr>';
    table += '<td class='+(item.ok ? 'OK' : 'miniEmpty')+'>'+item.ok+'</td>';
    table += '<td class='+(item.warning ? 'WARNING' : 'miniEmpty')+'>'+item.warning+'</td>';
    table += '<td class='+(item.critical ? 'CRITICAL' : 'miniEmpty')+'>'+item.critical+'</td>';
    table += '<td class='+(item.unknown ? 'UNKNOWN' : 'miniEmpty')+'>'+item.unknown+'</td>';
    table += '<td class='+(item.pending ? 'PENDING' : 'miniEmpty')+'>'+item.pending+'</td>';
    table += '</tr></table>';
    return(table);
}

/* returns group status */
TP.get_group_status = function(options) {
    var group          = options.group,
        incl_svc       = options.incl_svc,
        incl_hst       = options.incl_hst;
        incl_ack       = options.incl_ack;
        incl_downtimes = options.incl_downtimes;
    var s;
    var acknowledged = false;
    var downtime     = false;
         if(incl_svc && group.services.unknown > 0)                              { s = 3; }
    else if(incl_svc && incl_ack && group.services.ack_unknown > 0)              { s = 3; }
    else if(incl_svc && incl_downtimes && group.services.downtimes_unknown > 0)  { s = 3; }
    else if(incl_hst && group.hosts.unreachable > 0)                             { s = 2; }
    else if(incl_hst && group.hosts.down        > 0)                             { s = 2; }
    else if(incl_ack && group.hosts.ack_unreachable > 0)                         { s = 2; }
    else if(incl_ack && group.hosts.ack_down        > 0)                         { s = 2; }
    else if(incl_hst && incl_downtimes && group.hosts.downtime_down        > 0)  { s = 2; }
    else if(incl_hst && incl_downtimes && group.hosts.downtime_unreachable > 0)  { s = 2; }
    else if(incl_svc && group.services.critical > 0)                             { s = 2; }
    else if(incl_svc && incl_ack && group.services.ack_critical > 0)             { s = 2; }
    else if(incl_svc && incl_downtimes && group.services.downtimes_critical > 0) { s = 2; }
    else if(incl_svc && group.services.warning > 0)                              { s = 1; }
    else if(incl_svc && incl_ack && group.services.ack_warning > 0)              { s = 1; }
    else if(incl_svc && incl_downtimes && group.services.downtimes_warning > 0)  { s = 1; }
    else                                                                         { s = 0; }
    if(s == 0) {
        var a = 0;
             if(incl_svc && group.services.ack_unknown       > 0) { a = 3; acknowledged = true; }
        else if(incl_hst && group.hosts.ack_unreachable      > 0) { a = 2; acknowledged = true; }
        else if(incl_hst && group.hosts.ack_down             > 0) { a = 2; acknowledged = true; }
        else if(incl_svc && group.services.ack_critical      > 0) { a = 2; acknowledged = true; }
        else if(incl_svc && group.services.ack_warning       > 0) { a = 1; acknowledged = true; }

        var d = 0;
             if(incl_svc && group.services.downtimes_unknown > 0) { d = 3; downtime     = true; }
        else if(incl_hst && group.hosts.downtime_unreachable > 0) { d = 2; downtime     = true; }
        else if(incl_hst && group.hosts.downtime_down        > 0) { d = 2; downtime     = true; }
        else if(incl_svc && group.services.downtime_critical > 0) { d = 2; downtime     = true; }
        else if(incl_svc && group.services.downtime_warning  > 0) { d = 1; downtime     = true; }
        s = Ext.Array.max([a,s,d]);
    }
    return({state: s, downtime: downtime, acknowledged: acknowledged});
}


/* Hostgroup Status Icon */
Ext.define('TP.HostgroupStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'hostgroup',
    iconName: 'Hostgroupname',
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.xdata.general.incl_hst       = true;
        this.xdata.general.incl_svc       = true;
        this.xdata.general.incl_downtimes = false;
        this.xdata.general.incl_ack       = false;
    },

    getGeneralItems: function() {
        var panel = this;
        return([
            TP.objectSearchItem(panel, 'hostgroup', 'Hostgroupname'),
            {
                fieldLabel: 'Include Hosts',
                xtype:      'checkbox',
                name:       'incl_hst'
            }, {
                fieldLabel: 'Include Services',
                xtype:      'checkbox',
                name:       'incl_svc'
            }, {
                fieldLabel: 'Include Downtimes',
                xtype:      'checkbox',
                name:       'incl_downtimes',
                boxLabel:   '(alert during downtimes too)'
            }, {
                fieldLabel: 'Include Acknowledged',
                xtype:      'checkbox',
                name:       'incl_ack',
                boxLabel:   '(alert for acknowledged problems too)'
            }
        ]);
    },
    refreshHandler: function(newStatus) {
        // calculate summarized status
        if(this.hostgroup) {
            var res = TP.get_group_status({
                group:          this.hostgroup,
                incl_ack:       this.xdata.general.incl_ack,
                incl_downtimes: this.xdata.general.incl_downtimes,
                incl_svc:       this.xdata.general.incl_svc,
                incl_hst:       this.xdata.general.incl_hst
            });
            newStatus         = res.state;
            this.downtime     = res.downtime;
            this.acknowledged = res.acknowledged;
        }
        this.callParent([newStatus]);
    },
    getName: function() {
        return(this.xdata.general.hostgroup);
    },
    getDetails: function() {
        var details = [];
        if(!this.hostgroup) {
            return([['Status', 'No status information available']]);
        }
        var statename = TP.text_service_status(this.xdata.state);
        details.push([ 'Summarized Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>'
                                            +(this.acknowledged ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_ack.png" style="vertical-align:text-bottom"> acknowledged)':'')
                                            +(this.downtime     ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_downtime.png" style="vertical-align:text-bottom"> in downtime)':'')
                     ]);
        if(this.xdata.general.incl_hst) {
            details.push([ 'Hosts', TP.get_summarized_hoststatus(this.hostgroup.hosts)]);
        }
        if(this.xdata.general.incl_svc) {
            details.push([ 'Services', TP.get_summarized_servicestatus(this.hostgroup.services)]);
        }
        return(details);
    }
});

/* Service Status Icon */
Ext.define('TP.ServiceStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'service',
    iconName: 'Servicename',
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.xdata.general.incl_downtimes = false;
        this.xdata.general.incl_ack       = false;
    },

    getGeneralItems: function() {
        var panel = this;
        return([
            TP.objectSearchItem(panel, 'host', 'Hostname'),
            TP.objectSearchItem(panel, 'service', 'Servicename'),
            {
                fieldLabel: 'Include Downtimes',
                xtype:      'checkbox',
                name:       'incl_downtimes',
                boxLabel:   '(alert during downtimes too)'
            }, {
                fieldLabel: 'Include Acknowledged',
                xtype:      'checkbox',
                name:       'incl_ack',
                boxLabel:   '(alert for acknowledged problems too)'
            }
        ]);
    },
    getName: function() {
        return(this.xdata.general.host + ' - ' + this.xdata.general.service);
    },
    getDetails: function() {
        var details = [];
        if(!this.service) {
            return([['Status', 'No status information available']]);
        }
        var statename = TP.text_service_status(this.xdata.state);
        details.push([ 'Current Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>'
                                            +' (for ' + TP.render_duration('', '', {data:this.service})+')'
                                            +(this.acknowledged ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_ack.png" style="vertical-align:text-bottom"> acknowledged)':'')
                                            +(this.downtime     ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_downtime.png" style="vertical-align:text-bottom"> in downtime)':'')
                     ]);
        details.push([ 'Status Information', this.service.plugin_output]);
        details.push([ 'Last Check', this.service.last_check ? TP.date_format(this.service.last_check) : 'never']);
        details.push([ 'Last Notification', (this.service.last_notification == 0 ? 'N/A' : TP.date_format(this.service.last_notification)) + ' (notification '+this.service.current_notification_number+')']);
        return(details);
    },
    refreshHandler: function(newStatus) {
        this.acknowledged = false;
        this.downtime     = false;
        if(this.service) {
            if(this.service.scheduled_downtime_depth > 0) { this.downtime     = true; }
            if(this.service.acknowledged             > 0) { this.acknowledged = true; }
        }
        this.callParent([newStatus]);
    }
});

/* Servicegroup Status Icon */
Ext.define('TP.ServicegroupStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'servicegroup',
    iconName: 'Servicegroupname',
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.xdata.general.incl_downtimes = false;
        this.xdata.general.incl_ack       = false;
    },

    getGeneralItems: function() {
        var panel = this;
        return([
            TP.objectSearchItem(panel, 'servicegroup', 'Servicegroupname'),
            {
                fieldLabel: 'Include Downtimes',
                xtype:      'checkbox',
                name:       'incl_downtimes',
                boxLabel:   '(alert during downtimes too)'
            }, {
                fieldLabel: 'Include Acknowledged',
                xtype:      'checkbox',
                name:       'incl_ack',
                boxLabel:   '(alert for acknowledged problems too)'
            }
        ]);
    },
    refreshHandler: function(newStatus) {
        // calculate summarized status
        if(this.servicegroup) {
            var res = TP.get_group_status({
                group:          this.servicegroup,
                incl_ack:       this.xdata.general.incl_ack,
                incl_downtimes: this.xdata.general.incl_downtimes,
                incl_svc:       true,
                incl_hst:       false
            });
            newStatus         = res.state;
            this.downtime     = res.downtime;
            this.acknowledged = res.acknowledged;
        }
        this.callParent([newStatus]);
    },
    getName: function() {
        return(this.xdata.general.servicegroup);
    },
    getDetails: function() {
        var details = [];
        if(!this.servicegroup) {
            return([['Status', 'No status information available']]);
        }
        var statename = TP.text_service_status(this.xdata.state);
        details.push([ 'Summarized Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>'
                                            +(this.acknowledged ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_ack.png" style="vertical-align:text-bottom"> acknowledged)':'')
                                            +(this.downtime     ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_downtime.png" style="vertical-align:text-bottom"> in downtime)':'')
                     ]);
        details.push([ 'Services', TP.get_summarized_servicestatus(this.servicegroup.services)]);
        return(details);
    }
});

/* Custom Filter Icon */
Ext.define('TP.FilterStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'filtered',
    initComponent: function() {
        var panel = this;
        this.callParent();
        this.xdata.general.name           = '';
        this.xdata.general.incl_hst       = true;
        this.xdata.general.incl_svc       = true;
        this.xdata.general.incl_downtimes = false;
        this.xdata.general.incl_ack       = false;
    },

    getGeneralItems: function() {
        var panel = this;
        return([{
                fieldLabel: 'Name',
                xtype:      'textfield',
                name:       'name',
                value:      ''
            },
            new TP.formFilter({
                fieldLabel: 'Filter',
                name:       'filter',
                ftype:      'service',
                labelWidth: 132,
                panel:      panel
            }), {
                fieldLabel: 'Include Hosts',
                xtype:      'checkbox',
                name:       'incl_hst'
            }, {
                fieldLabel: 'Include Services',
                xtype:      'checkbox',
                name:       'incl_svc'
            }, {
                fieldLabel: 'Include Downtimes',
                xtype:      'checkbox',
                name:       'incl_downtimes',
                boxLabel:   '(alert during downtimes too)'
            }, {
                fieldLabel: 'Include Acknowledged',
                xtype:      'checkbox',
                name:       'incl_ack',
                boxLabel:   '(alert for acknowledged problems too)'
            }
        ]);
    },
    refreshHandler: function(newStatus) {
        // calculate summarized status
        if(this.results) {
            var res = TP.get_group_status({
                group:          this.results,
                incl_ack:       this.xdata.general.incl_ack,
                incl_downtimes: this.xdata.general.incl_downtimes,
                incl_svc:       this.xdata.general.incl_svc,
                incl_hst:       this.xdata.general.incl_hst
            });
            newStatus         = res.state;
            this.downtime     = res.downtime;
            this.acknowledged = res.acknowledged;
        }
        this.callParent([newStatus]);
    },
    getName: function() {
        return(this.xdata.general.name);
    },
    getDetails: function() {
        var details = [];
        if(!this.results) {
            return([['Status', 'No status information available']]);
        }
        var statename;
        if(this.xdata.general.incl_svc == false) {
            statename = TP.text_host_status(this.xdata.state);
        } else {
            statename = TP.text_service_status(this.xdata.state);
        }
        details.push([ 'Summarized Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>'
                                            +(this.acknowledged ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_ack.png" style="vertical-align:text-bottom"> acknowledged)':'')
                                            +(this.downtime     ?' (<img src="[% url_prefix %]plugins/panorama/images/btn_downtime.png" style="vertical-align:text-bottom"> in downtime)':'')
                     ]);
        if(this.xdata.general.incl_hst) {
            details.push([ 'Hosts', TP.get_summarized_hoststatus(this.results.hosts)]);
        }
        if(this.xdata.general.incl_svc) {
            details.push([ 'Services', TP.get_summarized_servicestatus(this.results.services)]);
        }
        return(details);
    }
});

/* Sitestatus Icon */
Ext.define('TP.SiteStatusIcon', {
    extend: 'TP.IconWidget',

    iconType: 'site',
    iconName: 'Sitename',
    initComponent: function() {
        var panel = this;
        this.callParent();
    },
    getGeneralItems: function() {
        var panel = this;
        return([
            TP.objectSearchItem(panel, 'site', 'Sitename')
        ]);
    },
    refreshHandler: function(newStatus) {
        // calculate site status
        if(this.site) {
                 if(this.site.running == 1) { newStatus = 0; }
            else if(this.site.state   == 0) { newStatus = 0; }
            else                            { newStatus = 2; }
        } else if(newStatus == undefined) {
            newStatus = this.state;
        }
        this.callParent([newStatus]);
    },
    getName: function() {
        return(this.xdata.general.site);
    },
    getDetails: function() {
        var details = [];
        if(!this.site) {
            return([['Status', 'No status information available']]);
        }
        var statename = this.xdata.state == 0 ? 'Ok' : 'Down';
        details.push([ 'Status', '<div class="extinfostate '+statename.toUpperCase()+'">'+statename.toUpperCase()+'<\/div>']);
        if(this.xdata.state == 0) {
            details.push([ 'Details', "Operating normal"]);
        } else {
            details.push([ 'Details', this.site.last_error]);
            details.push([ 'Address', this.site.addr]);
        }
        return(details);
    }
});

/* TextLabel Widget */
Ext.define('TP.TextLabelWidget', {
    extend: 'Ext.Component',
    mixins: {
        smallWidget: 'TP.SmallWidget'
    },
    iconType:           'text',
    html:               '',
    initialSettingsTab: 4,
    rotateLabel:        true,
    constructor: function (config) {
        this.mixins.smallWidget.constructor.call(this, config);
        this.callParent();
    },
    initComponent: function() {
        this.callParent();
        var panel = this;
        panel.xdata.label.labeltext = 'Label';
    },
    getGeneralItems: function() { return; },
    refreshHandler: function()  { return; }
});

/* delay link opening to allow double click menu */
TP.iconClickHandler = function(id) {
    if(Ext.getCmp(id).passClick) { return true; }
    window.clearTimeout(TP.timeouts['click'+id]);
    TP.timeouts['click'+id] = window.setTimeout(function() {
        TP.iconClickHandlerDo(id);
    }, 500);
    return false;
}
/* actually open the clicked link */
TP.iconClickHandlerDo = function(id) {
    var panel = Ext.getCmp(id);
    if(!panel || !panel.xdata || !panel.xdata.link || !panel.xdata.link.link) {
        return;
    }
    var link   = panel.xdata.link.link;
    var newTab = panel.xdata.link.newtab;
    var matches = link.match(/dashboard:\/\/(\d+)$/);
    if(matches && matches[1]) {
        // is that tab already open?
        var tabpan = Ext.getCmp('tabpan');
        var tab_id = "tabpan-tab_"+matches[1];
        var tab    = Ext.getCmp(tab_id);
        if(tab) {
            tabpan.setActiveTab(tab);
        } else {
            var replace;
            if(!newTab) {
                replace = tabpan.getActiveTab().id;
            }
            TP.add_pantab(tab_id, replace);
        }
    } else {
        panel.el.dom.href=link;
        panel.passClick = true;
        if(newTab) {
            panel.el.dom.target='_blank';
        }
        panel.el.dom.click();
        window.setTimeout(function() {
            panel.passClick = false;
        }, 300);
    }
};

/* return link representing the data for this icon */
TP.getIconDetailsLink = function(panel) {
    if(!panel.xdata || !panel.xdata.general) {
        return('#');
    }
    var cfg = panel.xdata.general;
    var options = {
        backends: TP.getActiveBackendsPanel(Ext.getCmp(panel.panel_id))
    };
    var base = "status.cgi";
    if(cfg.hostgroup) {
        options.hostgroup = cfg.hostgroup;
    }
    else if(cfg.service) {
        options.host    = cfg.host;
        options.service = cfg.service;
        options.type    = 2;
        base            = "extinfo.cgi";
    }
    else if(cfg.servicegroup) {
        options.servicegroup = cfg.servicegroup;
    }
    else if(cfg.host) {
        options.host = cfg.host;
    }
    else if(cfg.filter) {
        options.filter = cfg.filter;
        options.task   = 'redirect_status';
        base           = 'panorama.cgi';
    } else {
        return('#');
    }
    [%+ IF use_frames +%]
        return("[% url_prefix %]#cgi-bin/"+base+"?"+Ext.Object.toQueryString(options));
    [% ELSE %]
        return(base+"?"+Ext.Object.toQueryString(options));
    [% END %]
}

/* get gradient for color */
TP.createGradient = function(color, num, color2, percent) {
    if(num == undefined) { num = 0.2; }
    color  = Ext.draw.Color.fromString(color);
    if(color == undefined) { color = Ext.draw.Color.fromString('#DDDDDD'); }
    color2 = color2 ? Ext.draw.Color.fromString(color2) : color;
    var start;
    var end;
    if(num > 0) {
        start = color2.getLighter(Number(num)).toString();
        end   = color.toString();
    } else if (num < 0) {
        start = color.toString();
        end   = color2.getDarker(Number(-num)).toString();
    }
    var colorname = color.toString().replace(/^#/, '');
    var g = {
        id: 'fillGradient'+colorname+num,
        angle: 45,
        stops: {
              0: { color: start }
        }
    };
    if(percent != undefined) {
        if(percent > 10 && percent < 90) {
            g.stops[percent-10] = { color: start };
            g.stops[percent+10] = { color: end };
        } else {
            g.stops[percent] = { color: end };
        }
        g.stops[100]     = { color: end };
    } else {
        g.stops[100]     = { color: end };
    }
    return(g);
}

/* extract min/max */
TP.getPerfDataMinMax = function(p, maxDefault) {
    var r = { warn: undefined, crit: undefined, min: 0, max: maxDefault };
    if(p.max)           { r.max = p.max; }
    else if(p.crit_max) { r.max = p.crit_max; }
    else if(p.warn_max) { r.max = p.warn_max; }

    if(p.min)           { r.min = p.min; }
    return(r);
}
